package <%= packageName %>

//goland:noinspection GoUnusedExportedFunction
func Bool(v bool) *bool {
	return &v
}

//goland:noinspection GoUnusedExportedFunction
func BoolSlice(v []bool) []*bool {
	return Slice[bool](v)
}

//goland:noinspection GoUnusedExportedFunction
func Float32(v float32) *float32 {
	return &v
}

//goland:noinspection GoUnusedExportedFunction
func Float32Slice(v []float32) []*float32 {
	return Slice[float32](v)
}

//goland:noinspection GoUnusedExportedFunction
func Float64(v float64) *float64 {
	return &v
}

//goland:noinspection GoUnusedExportedFunction
func Float64Slice(v []float64) []*float64 {
	return Slice[float64](v)
}

//goland:noinspection GoUnusedExportedFunction
func Int(v int) *int {
	return &v
}

//goland:noinspection GoUnusedExportedFunction
func IntSlice(v []int) []*int {
	return Slice[int](v)
}

//goland:noinspection GoUnusedExportedFunction
func Int32(v int32) *int32 {
	return &v
}

//goland:noinspection GoUnusedExportedFunction
func Int32Slice(v []int32) []*int32 {
	return Slice[int32](v)
}

//goland:noinspection GoUnusedExportedFunction
func Int64(v int64) *int64 {
	return &v
}

//goland:noinspection GoUnusedExportedFunction
func Int64Slice(v []int64) []*int64 {
	return Slice[int64](v)
}

func Slice[T interface{}](v []T) []*T {
	out := make([]*T, len(v))
	for i := range v {
		out[i] = &v[i]
	}
	return out
}

//goland:noinspection GoUnusedExportedFunction
func String(v string) *string {
	return &v
}

//goland:noinspection GoUnusedExportedFunction
func StringSlice(v []string) []*string {
	return Slice[string](v)
}
